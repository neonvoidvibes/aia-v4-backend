<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../static/gradient_themes.css">
    <title>Magic Chat - {{ agent_name }}</title>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --base-bg: #0a0a0a;  /* Dark mode/evening default */
            --chat-bg: rgba(0, 0, 0, 0);  /* Fully transparent */
            --text-color: rgb(255, 255, 255); /* Default text color for body/other elements */
            --input-bg: transparent;
            --input-field-bg: rgba(252, 252, 252, 0.9);
            --accent-color: transparent;
            --accent-color-hover: rgba(31, 31, 31, 0.3);
            --action-color: rgb(137, 137, 137);  /* Dark icon color */
            --action-color-hover: rgb(20, 20, 20);  /* Even darker on hover */
            --trigger-color: rgb(31, 31, 31);
            --trigger-color-hover: rgb(131, 131, 131);
            /* --message-user-bg: #292929; */
            --message-user-bg: rgba(24, 24, 24, 0.95);
            --message-assistant-bg: rgba(255, 255, 255, 0.90);
            /* --message-system-bg: #4a4a4a; */
            --message-system-bg: #ffffff;
            --status-bar: #222222;
            --send-button: #1e1e1e;  /* New variable for send button arrow color */
            --placeholder-color: #c7c7c7;  /* New variable for input placeholder */
        }

        @font-face {
            font-family: 'Avenir Next', 'SF Pro Display', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            src: url('path-to-avenir-next-font.woff2') format('woff2');
            font-weight: 100;
            font-style: normal;
        }

        body {
            font-family: 'Avenir Next', 'SF Pro Display', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-weight: 300;
            margin: 0;
            padding: 0;
            color: var(--text-color);
            font-size: 20px;
            line-height: 1.5;
            overflow: hidden;
            height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #bg-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: var(--base-bg);  /* Near-black background */
            /* background-image: url('../static/images/river_bg01.jpg'); */
            /* background-size: 100% 100%; */
            /* background-position: center; */
            /* background-repeat: no-repeat; */
        }

        /* Adjust container transparency based on background type */
        .use-image-bg ~ #chat-container {
            background: rgba(0, 0, 0, 0);  /* Fully transparent */
        }

        .gradient-background ~ #chat-container {
            background: rgba(0, 0, 0, 0);  /* Fully transparent */
        }

        #chat-container {
            background: rgba(0, 0, 0, 0);
            /* border-radius: 25px; */ /* Removed rounded corners */
            box-shadow: 0;
            padding: 15px 40px 5px 40px;
            width: calc(75% - 80px);
            max-width: calc(1000px - 40px);
            height: 97vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin-top: -3vh;
        }

        h2 {
            text-align: center;
            margin: 10px 0 5px 0;  /* Increased top margin from 0 to 10px */
            font-size: 20px;
            color: var(--message-system-bg);
            font-weight: 100;
        }

        #chat-messages {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            margin-bottom: 5px;
            padding: 20px 10px 20px 10px; /* Restored standard padding */
            /* border-radius: 25px; */ /* Removed rounded corners from message area */
            background: var(--input-bg);
            width: calc(100% - 20px); /* Adjusted width based on padding */
            display: flex;
            flex-direction: column;
            position: relative; /* Needed for scrollbar */
            scrollbar-width: thin; /* For Firefox */
            scrollbar-color: rgba(100, 100, 100, 0.5) transparent; /* For Firefox */
        }
        /* Webkit scrollbar styling */
        #chat-messages::-webkit-scrollbar {
            width: 8px;
        }
        #chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        #chat-messages::-webkit-scrollbar-thumb {
            background-color: rgba(100, 100, 100, 0.5);
            border-radius: 4px;
            border: 2px solid transparent; /* Optional: adds padding around thumb */
            background-clip: content-box; /* Optional: makes border act as padding */
        }
        #chat-messages::-webkit-scrollbar-thumb:hover {
            background-color: rgba(130, 130, 130, 0.7);
        }


        #chat-messages.thinking {
            display: none;
        }

        #chat-messages.thinking-end {
            display: none;
        }

        @keyframes gradientFlow {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        @keyframes fadeInGlow {
            from { border-color: transparent; }
            to { border-color: rgba(66, 220, 219, 0.5); }
        }

        @keyframes fadeOutGlow {
            from { border-color: rgba(66, 220, 219, 0.5); }
            to { border-color: transparent; }
        }

        @keyframes neonGlow {
            0%, 100% { border-color: rgba(146, 53, 189, 0.75); }
            12% { border-color: rgba(254, 68, 154, 0.75); }
            25% { border-color: rgba(255, 126, 100, 0.75); }
            37% { border-color: rgba(236, 194, 24, 0.75); }
            50% { border-color: rgba(140, 255, 118, 0.75); }
            62% { border-color: rgba(0, 131, 226, 0.75); }
            75% { border-color: rgba(0, 170, 255, 0.75); }
            87% { border-color: rgba(74, 86, 255, 0.75); }
        }

        @keyframes letterGlow {
            0% { 
                opacity: 0;
                color: rgba(146, 53, 189, 1);
            }
            15% { 
                opacity: 1;
                color: rgba(254, 68, 154, 1);
            }
            30% { color: rgba(255, 126, 100, 1); }
            45% { color: rgba(236, 194, 24, 1); }
            60% { color: rgba(140, 255, 118, 1); }
            75% { color: rgba(0, 131, 226, 1); }
            90% { 
                color: rgba(74, 86, 255, 1);
            }
            100% { 
                opacity: 1;
                color: rgba(255, 255, 255, 0.7);
            }
        }

        @keyframes firstRevealGlow {
            0% { 
                opacity: 0;
                color: rgba(146, 53, 189, 1);
            }
            15% { 
                opacity: 1;
                color: rgba(254, 68, 154, 1);
            }
            30% { color: rgba(255, 126, 100, 1); }
            45% { color: rgba(236, 194, 24, 1); }
            60% { color: rgba(140, 255, 118, 1); }
            75% { color: rgba(0, 131, 226, 1); }
            90% { 
                color: rgba(74, 86, 255, 1);
                opacity: 1;
            }
            95% { 
                color: rgba(74, 86, 255, 1);
                opacity: 1;
            }
            100% { 
                color: rgba(255, 255, 255, 0.7);
                opacity: 1;
            }
        }

        @keyframes typeAndGlow {
            0% { 
                opacity: 0;
                transform: translateY(10px);
            }
            100% { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        .glow-text {
            white-space: pre;  
            font-weight: 700;
            color: rgba(255, 255, 255, 0.7);
            font-size: 40px;
            opacity: 0;
            display: inline-block;
            margin-right: 0.1em;
        }

        @media (max-width: 600px) {
            .glow-text {
                font-size: 32px;
            }
        }

        #welcome-text {
            position: absolute;
            top: 65%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            width: 100%;
            white-space: pre-wrap;
            pointer-events: none;
        }

        .glow-text.first-reveal {
            animation: firstRevealGlow 1.5s ease-out forwards;
        }

        .glow-text.visible {
            opacity: 1;
        }

        .glow-text.active {
            animation: typeAndGlow 0.3s ease-out forwards;
            opacity: 1;
        }

        #welcome-container {
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.7);
            font-weight: 700;
            letter-spacing: -0.15em;  
        }

        .message-wrapper {
            display: flex;
            margin-top: 0; /* Ensure consistent spacing */
            margin-bottom: 15px; /* Consistent spacing below each message group */
            width: fit-content;
            max-width: 100%;
        }

        /* User wrapper: align right */
        .message-wrapper.user {
            align-self: flex-end;
            flex-direction: row-reverse; /* Button visually first (left) */
            align-items: center; /* Vertically align button and bubble */
            margin-left: auto;
        }
         /* Assistant wrapper: align left, stack bubble and button */
        .message-wrapper.assistant {
            align-self: flex-start;
            flex-direction: column; /* Stack bubble and button */
            align-items: flex-start; /* Align items left */
        }


        .message {
             margin-bottom: 0;
            padding: 18px 22px;
            border-radius: 35px;
            font-size: 20px;
            animation: fadeIn 0.5s ease-out;
            white-space: pre-wrap;
            word-wrap: break-word;
            transition: background 0.2s ease, padding 0.2s ease; /* Add transition for waiting state */
        }

        .message.command {
            color: #20B2AA;  /* Light sea green / teal color */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .user-message {
            background: var(--message-user-bg);
            padding-left: 25px;
            border-bottom-right-radius: 5px;
            text-align: left;
            color: #ffffff;
             max-width: 80%; /* Increased width */
             /* margin-left: auto; */ /* Wrapper handles alignment */
        }

        .assistant-message {
            background: var(--message-assistant-bg);
            padding-left: 25px;
            border-bottom-left-radius: 5px;
            color: #000000;
             max-width: 95%;
             /* margin-right: auto; */ /* Wrapper handles alignment */
        }

        /* Style for assistant bubble when only showing waiting dot */
        .assistant-message.is-waiting {
             background: transparent;
             padding: 10px; /* Minimal padding for the dot */
             /* Ensure dot itself is visible */
             min-height: 30px; /* Give it some space */
             display: inline-flex; /* Align dot */
             align-items: center;
             justify-content: center;
             border-radius: 50%; /* Make it roundish */
        }


        .system-message {
            background: var(--message-system-bg);
            margin: 15px auto; /* Standard margin */
            text-align: center;
            color: #000000;
        }

        /* Copy Button General Styles */
        .copy-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px; /* Padding inside the button */
            opacity: 0; /* Hidden by default */
            width: 32px; /* Adjusted size (-10% from 36px -> 32.4 -> 32px) */
            height: 32px; /* Adjusted size (-10% from 36px -> 32.4 -> 32px) */
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease-in-out; /* Only opacity transition */
             /* remove absolute positioning */
        }

        .copy-button svg {
             width: 100%;
             height: 100%;
             display: block;
        }

        /* User Copy Button Specifics */
        .message-wrapper.user .copy-button {
             /* Position in flow */
             color: var(--message-user-bg);
             margin-right: 8px; /* Add space between icon and bubble */
             order: 1; /* Ensure it comes before message due to row-reverse */
        }

         /* Assistant Copy Button Specifics */
         .message-wrapper.assistant .copy-button {
             /* Position in flow */
             color: var(--message-assistant-bg);
             align-self: flex-start;
             margin-top: 8px; /* Static margin below bubble */
             /* Removed animation properties */
         }

        /* Hover/Focus states to show buttons */
        @media (hover: hover) {
            .message-wrapper:hover .copy-button {
                opacity: 0.7;
            }
            /* Removed assistant hover animation rules */
            .message-wrapper .copy-button:hover {
                 opacity: 1;
            }
        }
        /* Show on focus-within for accessibility/mobile tap */
         .message-wrapper:focus-within .copy-button {
              opacity: 0.7;
         }
         /* Removed assistant focus-within animation rules */


        #input-container {
            display: flex;
            gap: 10px;
            position: relative;
            padding: 0 10px;
            margin-bottom: 8px;  
            transform: translateY(0);
        }

        .action-buttons {
            display: flex;
            flex-direction: column-reverse;
            gap: 8px;
            position: absolute;
            left: 30px;
            bottom: 13px;
            z-index: 1;
        }

        .action-buttons::before {
            content: '';
            position: absolute;
            inset: -10px;
            background: rgba(252, 252, 252, 0.95);  /* Light background */
            border-radius: 20px;
            z-index: -1;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);  /* Lighter shadow */
            backdrop-filter: blur(8px);
            transform: translateY(-4px) translateX(0);
        }

        .action-buttons:hover::before {
            opacity: 1;
            transform: translateY(-4px) translateX(4px);
        }

        .action-buttons .action-button:not(#menu-trigger) {
            display: none;
            opacity: 0;
            transition: all 0.3s ease;
            transform: translateY(38px) translateX(0);
        }

        .action-buttons:hover .action-button:not(#menu-trigger) {
            display: flex;
            opacity: 1;
            transform: translateY(-4px) translateX(4px);
        }

        .action-buttons:hover #menu-trigger {
            opacity: 0;
            pointer-events: none;
        }

        #menu-trigger {
            display: flex;
            opacity: 1;
            position: absolute;
            bottom: 0;
            left: 0;
            color: var(--trigger-color);
            transition: opacity 0.3s ease;
            width: 37px;
            height: 37px;
            padding: 4px;
            background-color: transparent; /* Ensure default background is transparent */
        }
         #menu-trigger:hover {
             /* background-color: rgba(100, 60, 150, 0.8); /* Optional: Slightly darker/more opaque on hover */
             color: var(--trigger-color-hover); /* Uses the hover color variable */
         }

        #menu-trigger svg {
            width: 100%;
            height: 100%;
        }

        /* #menu-trigger:hover { */
            /* color: var(--trigger-color-hover); */
        /* } */

        @media (min-width: 601px) {
            .action-buttons {
                left: 22px;
                gap: 8px;
            }
        }

        @media (max-width: 600px) {
             #chat-messages {
                 padding-left: 10px; /* Mobile chat padding */
                 padding-right: 10px;
                 width: calc(100% - 20px); /* Adjust width */
            }
            /* Mobile copy button adjustments */
             .copy-button {
                 width: 26px; /* Adjusted size (-10% from 29px -> 26.1 -> 26) */
                 height: 26px;
                 padding: 4px;
            }
            .message-wrapper.user .copy-button {
                 margin-right: 6px; /* Adjust mobile margin */
                 order: 1; /* Keep button first visually */
            }
             /* No special hover animation needed for assistant button */
            .message-wrapper.assistant .copy-button {
                 margin-top: 6px; /* Adjust mobile margin */
            }

            .action-buttons {
                left: 22px;
                gap: 8px;
                bottom: 12px;
            }

            #menu-trigger {
                width: 31px;
                height: 31px;
            }

            #send-button {
                width: 36px;
                height: 36px;
                right: 20px;
                bottom: 9px;
            }

            /* Smaller stop button SVG on mobile */
            #send-button.streaming svg {
                 width: 18px;
                 height: 18px;
            }
        }

        .action-button {
            background: transparent;
            border: none;
            color: var(--action-color);
            width: 30px;
            height: 30px;
            padding: 4px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: color 0.3s ease;
        }

        .action-button:hover {
            color: var(--action-color-hover);
        }

        .action-button svg {
            width: 100%;
            height: 100%;
        }

        #record-button {
            color: var(--action-color);
        }

        #record-button:hover {
            color: var(--action-color-hover);
        }

        #message-input {
            flex-grow: 1;
            padding: 18px 78px 20px 70px;
            border: none;
            border-radius: 35px;
            font-size: 20px;
            background: var(--input-field-bg);
            /* color: var(--text-color); /* CHANGED: Was using default white */
            color: #000000; /* CHANGED: Set input text color to black */
            outline: none;
            font-family: 'Avenir Next', 'SF Pro Display', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-weight: 300;
            resize: none;
            overflow-y: hidden;
            line-height: 24px;
            height: 62px;
            min-height: 62px;
            max-height: calc(62px + (24px * 4));
            box-sizing: border-box;
            display: block;
            white-space: pre-wrap;
            word-wrap: break-word;
            border: 4px solid transparent;
            border-width: 1px;
            border-style: solid;
            border-color: transparent;
        }

        @media (max-width: 600px) {
            #message-input {
                padding: 17px 65px 12px 50px;
                line-height: 20px;
                height: 54px;
                min-height: 54px;
                max-height: calc(54px + (20px * 4));
                font-size: 17px;
            }
        }

        #message-input.thinking {
            border-color: rgba(66, 220, 219, 0.5);
            animation: fadeInGlow 0.5s ease-in forwards,
                       neonGlow 3s ease-in-out infinite 0.5s;
        }

        #message-input.thinking-end {
            animation: fadeOutGlow 0.5s ease-out forwards;
        }

        #message-input::placeholder {
            color: var(--placeholder-color);
        }

        #send-button {
            position: absolute;
            right: 20px;
            bottom: 10px;
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background: var(--accent-color);
            color: var(--send-button);  /* Using the new variable */
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background 0.3s ease, color 0.2s ease; /* Added color transition */
        }

        @media (max-width: 600px) {
            #send-button {
                width: 36px;
                height: 36px;
                right: 20px;
                bottom: 9px;
            }
        }

        #send-button:hover {
            background: var(--accent-color-hover);
        }

        #send-button svg {
            width: 26px; /* Default size for send arrow */
            height: 26px;
            transition: transform 0.2s ease, width 0.2s ease, height 0.2s ease; /* Smooth transition for icon change */
        }

        /* Style for the smaller stop icon */
        #send-button.streaming svg {
             width: 22px; /* Slightly smaller stop icon */
             height: 22px;
        }


        @media (max-width: 600px) {
            #send-button svg {
                width: 20px; /* Mobile send arrow size */
                height: 20px;
            }
             /* Smaller stop button SVG on mobile */
            #send-button.streaming svg {
                 width: 18px;
                 height: 18px;
            }
        }

        #status-bar {
            font-size: 16px;
            color: var(--status-bar);
            margin: 0 0 5px 0;
            text-align: center;
            transform: translateY(0);
            position: relative;
            z-index: 100;
        }

        .waiting {
            display: inline-block;
            width: 10px;
            height: 10px;
            /* Use assistant bubble background color */
            background-color: var(--message-assistant-bg);
            border-radius: 50%;
            animation: breathe 2s ease-in-out infinite;
        }

        @keyframes breathe {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7;}
        }

        @media (max-width: 600px) {
            #chat-container {
                width: 100%;
                height: 100vh;
                padding: 20px 20px 15px 20px;
                border-radius: 0;
            }

            #chat-messages {
                flex: 1;
                width: 100%;
                margin: 0;
                padding: 0 10px 0 10px; /* Adjusted mobile messages padding */
            }

            h2 {
                margin: 20px 0 30px 0;
                font-size: 17px;
            }

            #input-container {
                margin: 15px 0 30px 0;
            }

            .message {
                font-size: 18px;
            }

            #welcome-text {
                top: 50%;
            }

            #status-bar {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- To switch between backgrounds, use one of these classes on bg-wrapper:
         - For solid color: bg-solid
         - For image: bg-image
         - For gradient: bg-gradient
    -->
    <div id="bg-wrapper" class="bg-wrapper bg-image"></div>
    <div id="chat-container">
        <h2>River AI</h2>
        <div id="chat-messages">
            <div id="welcome-container">
                <span id="welcome-text"></span>
            </div>
        </div>
        <div id="input-container">
            <div class="action-buttons">
                <button class="action-button" id="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                </button>
                <button class="action-button" id="record-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
                <button class="action-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                    </svg>
                </button>
                <button class="action-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a2 2 0 0 1 2.83 2.83l-8.49 8.48"></path>
                    </svg>
                </button>
                <!-- Save button restored for UI, functionality connected via JS -->
                <button class="action-button" id="save-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
            </div>
            <textarea id="message-input" placeholder="Message AI" rows="1"></textarea>
            <!-- Send button's onclick is now managed dynamically -->
            <button id="send-button">
                <!-- Initial icon is set in script -->
            </button>
        </div>
        <div id="status-bar"></div>
    </div>

    <script>
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const chatMessages = document.getElementById('chat-messages');
        const welcomeContainer = document.getElementById('welcome-text');

        let lastMessage = null;  // Track last message globally (less relevant now?)
        let isMobile = window.innerWidth <= 600;
        let initialHeight = isMobile ? '54px' : '62px';
        let currentAbortController = null; // Controller for stopping fetch stream
        let userHasScrolled = false; // Flag for scroll behavior
        let currentAssistantMessageWrapper = null; // Track the current assistant message wrapper

        // --- Icon SVGs ---
        const sendIconSVG = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="19" x2="12" y2="5"></line>
                <polyline points="5 12 12 5 19 12"></polyline>
            </svg>`;
        const stopIconSVG = `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            </svg>`;
        const copyIconSVG = `
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                 <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                 <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>`;
        const checkIconSVG = `
             <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                 <polyline points="20 6 9 17 4 12"></polyline>
            </svg>`;

        // --- Initialization ---
        function initializeChat() {
            messageInput.style.height = initialHeight;
            sendButton.innerHTML = sendIconSVG; // Set initial icon
            sendButton.onclick = sendMessage; // Set initial action

            // Event Listeners
            window.addEventListener('resize', handleResize);
            messageInput.addEventListener('input', handleInput);
            messageInput.addEventListener('keypress', handleKeyPress);
            chatMessages.addEventListener('scroll', handleScroll);

            initializeWelcomeText();
            animateWelcomeText();
            updateStatus();
            setInterval(updateStatus, 5000);
            setupSaveButton(); // Restore call to setup save button listener
        }

        // --- Event Handlers ---
        function handleResize() {
            const wasMobile = isMobile;
            isMobile = window.innerWidth <= 600;
            if (wasMobile !== isMobile) {
                initialHeight = isMobile ? '54px' : '62px';
                // Adjust height only if input is currently at initial height
                if (messageInput.style.height === (wasMobile ? '54px' : '62px')) {
                     messageInput.style.height = initialHeight;
                }
                 // Re-evaluate scroll height based on new initial height if needed
                 handleInput();
            }
        }

        function handleInput() {
            // Allow resize even when streaming
            messageInput.style.height = initialHeight; // Reset first
            const lineHeight = isMobile ? 20 : 24;
            const maxHeight = parseInt(initialHeight) + (lineHeight * 4);
            const newHeight = Math.min(messageInput.scrollHeight, maxHeight);
            messageInput.style.height = newHeight + 'px';
        }

        function handleKeyPress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                // Check button's current action by checking the assigned function
                if (sendButton.onclick === sendMessage) {
                    sendMessage();
                } else if (sendButton.onclick === stopStreaming) {
                     // Stop streaming if user presses Enter while streaming
                     stopStreaming();
                }
            }
        }

        function handleScroll() {
            // Consider user scrolled if not within ~10px of the bottom
            const threshold = 10;
            const isNearBottom = chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < threshold;
            userHasScrolled = !isNearBottom;
            // console.log("User scrolled:", userHasScrolled, " Near Bottom:", isNearBottom); // For debugging
        }

        // --- Core Functions ---
        function updateStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    const status = [];
                    // Assuming status endpoint provides these flags:
                    if (data.listen_summary) status.push('summary');
                    if (data.listen_transcript) status.push('transcript');
                    if (data.listen_insights) status.push('insights');

                    const statusBar = document.getElementById('status-bar');
                    if (!statusBar) return; // Exit if status bar not found
                    const statusText = status.length ? 'Listening to: ' + status.join(', ') : 'Not listening';
                    const memoryText = data.memory_enabled ? 'Memory: yes' : 'Memory: no';
                    statusBar.textContent = 'Agent: ' + '{{ agent_name }}' + ' \u00A0 | \u00A0 ' + statusText + ' \u00A0 | \u00A0 ' + memoryText;
                }).catch(error => console.error("Error fetching status:", error));
        }

        function setSendButtonState(state) {
             if (state === 'sending') {
                 sendButton.innerHTML = stopIconSVG;
                 sendButton.classList.add('streaming');
                 sendButton.onclick = stopStreaming; // Change action to stop
             } else { // 'idle' state
                 sendButton.innerHTML = sendIconSVG;
                 sendButton.classList.remove('streaming');
                 sendButton.onclick = sendMessage; // Change action to send
                 currentAbortController = null; // Ensure controller is cleared
                 currentAssistantMessageWrapper = null; // Clear reference to message wrapper
                 messageInput.classList.remove('thinking', 'thinking-end'); // Clear thinking styles
                 messageInput.disabled = false; // Re-enable input
                 // Only refocus if not mobile, to avoid keyboard annoyance
                 if (!isMobile) {
                      messageInput.focus();
                 }
                 handleInput(); // Recalculate input height
            }
        }

        function stopStreaming() {
            console.log("Attempting to stop stream...");
            if (currentAbortController) {
                // AbortController signals the fetch to stop.
                // Backend termination depends on server/library implementation supporting the signal.
                currentAbortController.abort();
                console.log("Abort signal sent.");
                // Bubble removal logic moved to AbortError catch block in sendMessage
            } else {
                 console.log("No active stream to stop.");
                 setSendButtonState('idle'); // Reset if state is inconsistent
            }
        }

        async function sendMessage() {
            const message = messageInput.value.trim();
            if (!message) return;

            const welcomeElem = document.getElementById('welcome-container');
            if (welcomeElem) welcomeElem.remove(); // Remove welcome text on first message

            // Disable input, clear, reset height
            messageInput.disabled = true;
            messageInput.value = '';
            messageInput.style.height = initialHeight;

            // Handle commands first
            if (message.startsWith('!')) {
                handleCommand(message);
                 messageInput.disabled = false; // Re-enable input after command
                return;
            }

            // --- Regular Message ---
            const userMessageWrapper = appendMessage('user', message); // Get wrapper
            // Scroll immediately after user message is appended and rendered
            requestAnimationFrame(() => {
                 chatMessages.scrollTop = chatMessages.scrollHeight;
            });

            messageInput.classList.add('thinking'); // Indicate processing start visually

            // Setup AbortController
            const controller = new AbortController();
            currentAbortController = controller; // Store the controller globally

            setSendButtonState('sending'); // Change button to Stop icon and action

            let assistantMessageContent = ''; // Accumulate message text
            currentAssistantMessageWrapper = appendMessage('assistant', '<span class="waiting"></span>'); // Store wrapper
            const assistantElementBubble = currentAssistantMessageWrapper.querySelector('.message'); // Get the bubble inside
            assistantElementBubble.classList.add('is-waiting'); // Add class for styling

            userHasScrolled = false; // Reset scroll lock for new message
            // Ensure initial scroll includes the new waiting bubble
            requestAnimationFrame(() => {
                if (!userHasScrolled) chatMessages.scrollTop = chatMessages.scrollHeight;
            });


            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message }),
                    signal: controller.signal // Pass the abort signal
                });

                if (!response.ok || !response.body) {
                     const errorText = response.body ? await response.text() : response.statusText;
                     throw new Error(`HTTP error ${response.status}: ${errorText || 'Failed to initiate stream'}`);
                 }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                     let chunkValue;
                     try {
                         const { done, value } = await reader.read();
                         if (done) {
                             console.log("Stream finished.");
                             break; // Exit loop
                         }
                         chunkValue = value;
                     } catch (readError) {
                         console.error("Error reading from stream:", readError);
                         throw readError; // Re-throw to be caught by outer try/catch
                     }


                    const chunk = decoder.decode(chunkValue, { stream: true });
                    const lines = chunk.split('\n');

                    lines.forEach(line => {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                if (data.delta) {
                                    const waitingSpan = assistantElementBubble.querySelector('.waiting');
                                    if (waitingSpan) {
                                        assistantElementBubble.innerHTML = ''; // Remove "Thinking..." message
                                        assistantElementBubble.classList.remove('is-waiting'); // Remove styling class
                                        messageInput.classList.add('thinking-end'); // Start fade out
                                        setTimeout(() => {
                                            messageInput.classList.remove('thinking', 'thinking-end');
                                        }, 500); // Remove thinking styles after fade
                                    }
                                    assistantMessageContent += data.delta; // Accumulate text
                                    assistantElementBubble.innerHTML += data.delta; // Append text directly

                                    if (!userHasScrolled) {
                                         requestAnimationFrame(() => {
                                             chatMessages.scrollTop = chatMessages.scrollHeight;
                                         });
                                    }
                                } else if (data.done) {
                                     console.log("Stream signaled done via data.");
                                } else if (data.error) {
                                     console.error("Stream reported error:", data.error);
                                     assistantElementBubble.textContent = `Error: ${data.error}`;
                                     assistantElementBubble.classList.remove('is-waiting'); // Ensure styling is removed on error too
                                 }
                            } catch (e) {
                                console.error("Error parsing JSON from stream:", e, "Line:", line);
                            }
                        }
                    });
                }
                 // Final actions after stream completes successfully
                 const waitingSpan = assistantElementBubble.querySelector('.waiting');
                 if (waitingSpan) { // If stream ended but only waiting span was shown
                     assistantElementBubble.innerHTML = '';
                     assistantElementBubble.classList.remove('is-waiting');
                 }
                 if (assistantMessageContent.trim() !== '') { // Only add copy button if there's actual content
                    currentAssistantMessageWrapper.dataset.rawText = assistantMessageContent; // Store final text on wrapper
                    addCopyButton(currentAssistantMessageWrapper, assistantMessageContent, 'assistant'); // Add copy button after content is final
                 } else if (currentAssistantMessageWrapper && !assistantElementBubble.querySelector('.waiting')) {
                     // If no content AND no waiting span, remove the bubble wrapper
                     console.log("Removing empty bubble after successful stream.");
                     currentAssistantMessageWrapper.remove();
                 }


                 if (!userHasScrolled) { // Perform final scroll if user wasn't scrolled up
                      requestAnimationFrame(() => {
                          chatMessages.scrollTop = chatMessages.scrollHeight;
                     });
                 }

            } catch (error) {
                 // Ensure waiting class is removed on any error/abort
                 if (assistantElementBubble) {
                     assistantElementBubble.classList.remove('is-waiting');
                 }
                 const waitingSpan = assistantElementBubble?.querySelector('.waiting');
                 if (waitingSpan) assistantElementBubble.innerHTML = ''; // Clear placeholder on error too

                if (error.name === 'AbortError') {
                    console.log('Stream stopped by user.');
                     // Check if content is still empty / only whitespace OR only the waiting span was present
                     if (currentAssistantMessageWrapper && assistantMessageContent.trim() === '') {
                          console.log("Removing empty bubble on abort.");
                          currentAssistantMessageWrapper.remove(); // Remove the whole wrapper
                     } else if (currentAssistantMessageWrapper) {
                         // Add copy button even for partial content if it exists
                         currentAssistantMessageWrapper.dataset.rawText = assistantMessageContent;
                         addCopyButton(currentAssistantMessageWrapper, assistantMessageContent, 'assistant');
                     }
                } else {
                    console.error('Stream or fetch error:', error);
                    if (assistantElementBubble) { // Ensure bubble exists
                       assistantElementBubble.textContent = `Error: ${error.message || 'Failed to get response'}`;
                    }
                }
            } finally {
                // Always reset button state and controller when stream ends
                setSendButtonState('idle');
            }
        }

        function handleCommand(message) {
             const command = message.substring(1).toLowerCase();
             appendMessage('user', message, true); // Display command visually
             requestAnimationFrame(() => { // Scroll after command input
                chatMessages.scrollTop = chatMessages.scrollHeight;
             });

             fetch('/api/command', {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify({ command: command })
             })
             .then(async response => {
                 const data = await response.json();
                 if (!response.ok) {
                     throw new Error(data.error || `Command failed with status ${response.status}`);
                 }
                 return data;
             })
             .then(data => {
                 if (data.message) {
                     appendMessage('assistant', data.message, true); // Show command response
                 }
                 updateStatus(); // Update status bar after command execution
             })
             .catch(error => {
                 console.error(`Error executing command !${command}:`, error);
                 appendMessage('assistant', `Error: ${error.message}`, true); // Show error message
             });
        }


        function appendMessage(sender, text, isCommand = false) {
             const welcomeElem = document.getElementById('welcome-container');
             if (welcomeElem) welcomeElem.remove();

            // Create wrapper
            const wrapperDiv = document.createElement('div');
            wrapperDiv.className = `message-wrapper ${sender.toLowerCase()}`;

            // Create message bubble
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender.toLowerCase()}-message`;
            if (isCommand) {
                messageDiv.classList.add('command');
            }
            // Store raw text for copy, use innerHTML for display (handles waiting span)
            const rawTextContent = (typeof text === 'string' && !text.includes('<span class="waiting"></span>')) ? text : '';
            messageDiv.innerHTML = text;
            wrapperDiv.dataset.rawText = rawTextContent; // Store raw text on wrapper

            wrapperDiv.appendChild(messageDiv);
            chatMessages.appendChild(wrapperDiv);

            // Add copy button immediately for user/command messages if text exists
            if ((sender === 'user' || isCommand) && rawTextContent) {
                addCopyButton(wrapperDiv, rawTextContent, sender);
            }

            // Scroll logic handled after append in calling function (sendMessage)

            // Return the wrapper element now (contains the bubble and potentially the button)
            return wrapperDiv;
        }

         // Helper function to add the copy button dynamically
         function addCopyButton(wrapperDiv, textContent, sender) {
             // Ensure textContent is a non-empty string before adding button
             if (!wrapperDiv || wrapperDiv.querySelector('.copy-button') || typeof textContent !== 'string' || !textContent.trim()) {
                 return;
             }

             const copyButton = document.createElement('button');
             copyButton.className = 'copy-button';
             copyButton.innerHTML = copyIconSVG;
             copyButton.title = 'Copy message';

             // Color is handled by CSS rules now

             copyButton.onclick = (event) => {
                 event.stopPropagation(); // Prevent potential wrapper events
                 const textToCopy = wrapperDiv.dataset.rawText || textContent;
                 copyToClipboard(textToCopy, copyButton);
             };

             // Append the button to the wrapper. CSS handles positioning/flow.
             wrapperDiv.appendChild(copyButton);
         }


        async function copyToClipboard(text, buttonElement) {
            if (!navigator.clipboard) {
                console.warn('Clipboard API not available');
                 buttonElement.innerHTML = 'Error'; // Simple text feedback
                 setTimeout(() => { buttonElement.innerHTML = copyIconSVG; }, 2000);
                return;
            }
            try {
                await navigator.clipboard.writeText(text);
                console.log('Text copied to clipboard');

                // Visual feedback
                const originalIcon = copyIconSVG; // Reference the constant SVG
                buttonElement.innerHTML = checkIconSVG;
                buttonElement.disabled = true;

                setTimeout(() => {
                    if (document.body.contains(buttonElement)) {
                         buttonElement.innerHTML = originalIcon;
                         buttonElement.disabled = false;
                    }
                }, 1500);

            } catch (err) {
                console.error('Failed to copy text: ', err);
                 buttonElement.innerHTML = 'Error'; // Simple text feedback
                 setTimeout(() => {
                     if (document.body.contains(buttonElement)) {
                          buttonElement.innerHTML = copyIconSVG;
                     }
                 }, 2000);
            }
        }


        // --- Welcome Text Animation ---
        function initializeWelcomeText() {
            if (!welcomeContainer) return;
            const welcomeTextContent = "What is alive today?";
            welcomeContainer.innerHTML = ''; // Clear first
            [...welcomeTextContent].forEach(char => {
                const span = document.createElement('span');
                span.textContent = char;
                span.className = 'glow-text';
                welcomeContainer.appendChild(span);
            });
        }

        function animateWelcomeText() {
             if (!welcomeContainer) return;
            const letters = welcomeContainer.querySelectorAll('.glow-text');
            if (letters.length === 0) return; // Don't run if no letters found
            letters.forEach((letter, index) => {
                setTimeout(() => {
                    letter.classList.add('first-reveal');
                }, index * 100); // Stagger animation
            });
        }

        // --- Save Button Setup ---
        // Re-added setupSaveButton function
        function setupSaveButton() {
            const saveButton = document.getElementById('save-button');
            if (saveButton) {
                saveButton.addEventListener('click', async () => {
                    let messageDiv; // To display feedback
                    try {
                        // Call the new dedicated /api/save endpoint
                        const response = await fetch('/api/save', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' }
                        });

                        const data = await response.json();
                        messageDiv = document.createElement('div');
                        if (chatMessages) {
                             chatMessages.appendChild(messageDiv);
                        } else {
                             console.error("Cannot find chatMessages element to append feedback.");
                             return;
                         }

                        if (response.ok) {
                            messageDiv.className = 'message system-message';
                            messageDiv.textContent = data.message || 'Chat saved successfully.';
                        } else {
                            // Use error message from backend response if available
                            throw new Error(data.error || `Failed to save chat (Status: ${response.status})`);
                        }
                    } catch (error) {
                        console.error('Error saving chat history:', error);
                         if (!messageDiv && chatMessages) {
                             messageDiv = document.createElement('div');
                             chatMessages.appendChild(messageDiv);
                         }
                         if (messageDiv) {
                            messageDiv.className = 'message system-message error'; // Add error class
                            messageDiv.textContent = `Error saving: ${error.message}`;
                         }
                    } finally {
                         // Auto-remove feedback message after a delay
                         if (messageDiv && chatMessages) {
                             setTimeout(() => { chatMessages.scrollTop = chatMessages.scrollHeight; }, 50);
                             setTimeout(() => {
                                 messageDiv.style.transition = 'opacity 0.5s ease-out';
                                 messageDiv.style.opacity = '0';
                                 setTimeout(() => messageDiv.remove(), 500);
                             }, 4000);
                         }
                    }
                });
            } else {
                console.warn("Save button element not found");
            }
        }

        // --- Run Initialization ---
        document.addEventListener('DOMContentLoaded', initializeChat);

    </script>
</body>
</html>